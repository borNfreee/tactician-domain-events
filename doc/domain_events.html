<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>Tactician Domain Events</title>

        <link rel="stylesheet" href="https://maks-rafalko.github.io/tactician-domain-events/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://maks-rafalko.github.io/tactician-domain-events/css/font-awesome.min.css">
        <link rel="stylesheet" href="https://maks-rafalko.github.io/tactician-domain-events/css/highlight.dark.css">
        <link rel="stylesheet" href="https://maks-rafalko.github.io/tactician-domain-events/css/main.css">
    </head>
    <body>

        <header class="navbar navbar-default navbar-fixed-top">

            <a class="navbar-brand" href="https://maks-rafalko.github.io/tactician-domain-events/">
                Tactician Domain Events
                <small class="hidden-xs hidden-sm">
                    A Plugin for Tactician command bus library to work with the recorded Domain Events
                </small>
            </a>

                            <a href="https://github.com/maks-rafalko/tactician-domain-events">
                    <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png">
                </a>
            
        </header>

        <main class="container-fluid">
            <div class="row">

                
                    <nav id="sidebar" class="col-sm-3 col-lg-2" role="navigation">

                        <ul class="nav nav-pills nav-stacked">
                                                            <li class="">
                                    <a href="https://maks-rafalko.github.io/tactician-domain-events/">
                                        Home
                                    </a>
                                </li>
                                                            <li class="active">
                                    <a href="https://maks-rafalko.github.io/tactician-domain-events/doc/domain_events.html">
                                        Domain events
                                    </a>
                                </li>
                                                            <li class="">
                                    <a href="https://maks-rafalko.github.io/tactician-doctrine-domain-events">
                                        Doctrine Integration
                                    </a>
                                </li>
                                                            <li class="">
                                    <a href="https://maks-rafalko.github.io/tactician-domain-events-bundle/">
                                        Symfony Integration
                                    </a>
                                </li>
                                                    </ul>

                    </nav>

                
                <section id="content" class="col-sm-offset-3 col-lg-offset-2 col-sm-9 col-lg-10">
                    <p>There are two possible ways to record Domain Events:</p>
<ul>
<li>Using the public service, <code>EventRecorder</code></li>
<li>Using the Entity</li>
</ul>
<h3 id="public-recorder">Public Recorder</h3>
<pre><code class="language-php">use BornFree\TacticianDomainEvent\Recorder\EventRecorder;

// it can be a service in your DI container
$eventRecorder = new EventRecorder();

$event = new TaskWasCreated('Finish review');

$eventRecorder-&gt;record($event);

// later in the source code we release the events and dispatch them
$recordedEvents = $eventRecorder-&gt;releaseEvents();</code></pre>
<p><code>$recordedEvents</code> array contains all recorded Domain Events, in this case the <code>TaskWasCreated</code> one, and can be dispatched with any dispatcher that implements <code>EventDispatcherInterface</code>:</p>
<pre><code class="language-php"> namespace BornFree\TacticianDomainEvent\EventDispatcher;

 interface EventDispatcherInterface
 {
     public function dispatch($event);
 }</code></pre>
<p>This lib contains the very basic implementation of <code>EventDispatcher</code>, but you can implement your own, see <a href="#event-dispatcher">Event Dispatcher</a> section below</p>
<h3 id="record-events-in-entity">Record events in Entity</h3>
<p>When you use domain events, your domain entities will generate events while you change or create them. You record those events inside the entity and when the changes have been persisted and the database transaction has succeeded, you should collect the recorded events and handle them:</p>
<pre><code class="language-php">$task = new Task('Finish review'); // records `TaskWasCreated` domain event

// start transaction
$entityManager-&gt;persist($entity);
// commit transaction

$events = $entity-&gt;releaseEvents();

// dispatch the events
foreach ($events as $event) {
    $eventDispatcher-&gt;dispatch($event);
}</code></pre>
<p>This is possible thanks to implementing <code>RecordsEvents</code> interface that has a <code>record()</code> method. You can use a built in <code>EventRecorderCapabilities</code> trait:</p>
<pre><code class="language-php">use BornFree\TacticianDomainEvent\Recorder\ContainsRecordedEvents;
use BornFree\TacticianDomainEvent\Recorder\EventRecorderCapabilities;

class Task implements ContainsRecordedMessages
{
    use EventRecorderCapabilities;

    public function __construct($name)
    {
        $this-&gt;record(new TaskWasCreated($name));
    }
}</code></pre>
<h2 id="event-dispatcher">Event Dispatcher</h2>
<p>Using the built in <code>EventDispatcher</code>, we can handle all recorded events:</p>
<pre><code class="language-php">use BornFree\TacticianDomainEvent\EventDispatcher;
...
$recordedEvents = $eventRecorder-&gt;releaseEvents();

$eventDispatcher = new EventDispatcher();

foreach ($recordedEvents as $event) {
    $eventDispatcher-&gt;dispatch($event);
}</code></pre>
<p>Now it's time to add listeners and react to dispatched events.</p>
<h3 id="add-event-listeners">Add Event Listeners</h3>
<p>The built in <code>EventDispatcher</code> accepts any <code>callable</code> as a listener. It means you can use regular methods, static methods, callable object with <code>__invoke()</code> function and even closures.</p>
<p>Let's write an event listener that sends notification when the task is created:</p>
<pre><code class="language-php">class SendPushNotificationListener
{
    public function __construct(PushNotificationSender $sender) {...}

    public function __invoke($event)
    {
        $this-&gt;sender-&gt;send($event-&gt;getName());
    }
}

$listener = new SendPushNotificationListener($sender);

$eventDispatcher-&gt;addListener(TaskWasCreated::class, $listener);</code></pre>
<p>Or using a closure:</p>
<pre><code class="language-php">$eventDispatcher-&gt;addListener(
    TaskWasCreated::class,
    function ($event) use ($sender) {
        $sender-&gt;send($event-&gt;getName());
    }
);
</code></pre>
<h3 id="add-event-subscribers">Add Event Subscribers</h3>
<p>It's also possible to add event subscribers: classes that handles multiple events. Your subscriber have to implement the interface:</p>
<pre><code class="language-php">interface EventSubscriberInterface
{
    /**
     * @return array
     */
    public function getSubscribedEvents();
}</code></pre>
<p>Method <code>getSubscribedEvents</code> should return an array, where keys are events and values are callables:</p>
<pre><code class="language-php">class MailerListener implements EventSubscriberInterface
{
    public function getSubscribedEvents()
    {
        return [
            UserWasCreated =&gt; [$this, 'sendActivationLink'],
            UserWasDeactivated =&gt; [$this, 'sendDeactivationInfo'],
        ];
    }

    public function sendActivationLink()
    {
        // ...
    }

    public function sendDeactivationInfo()
    {
        // ...
    }
}</code></pre>
<p>And adding it to dispatcher:</p>
<pre><code class="language-php">$eventDispatcher-&gt;addSubscriber(new MailerListener());</code></pre>
<h2 id="handling-events-with-tactician-command-bus">Handling events with Tactician command bus</h2>
<h3 id="handling-recorded-events-from-public-recorder">Handling recorded events from public recorder</h3>
<p>Events are recorded while a command is handled. We only want to handle the events themselves <strong>after</strong> the command has completely and successfully been handled. The best option to accomplish this is to add a middleware to the command bus. This middleware needs the event recorder to find out which events were recorded during the handling of commands, and it needs the event dispatcher to actually dispatch the recorded events:</p>
<pre><code class="language-php">use League\Tactician\CommandBus;
use League\Tactician\Doctrine\ORM\TransactionMiddleware;
use BornFree\TacticianDomainEvent\Middleware\ReleaseRecordedEventsMiddleware;

// see the previous sections about $eventRecorder and $eventDispatcher
$releaseRecordedEventsMiddleware = new ReleaseRecordedEventsMiddleware($eventRecorder, $eventDispatcher);

$commandBus = new CommandBus(
    [
        $releaseRecordedEventsMiddleware, // it should be before transaction middleware
        $transactionMiddleware,
        $commandHandlerMiddleware
    ]
);
</code></pre>
<p>We only want events to be handled when we know that everything else has gone well and transaction has been committed.</p>
<h3 id="handling-domain-events-from-entities">Handling domain events from Entities</h3>
<p>When you privately record events inside your domain entities, you need to collect those recorded events manually. Your database abstraction library, ORM or ODM probably offers a way to hook into the process of persisting the entities and collecting them somehow. After the command has been handled successfully and the transaction has been committed, you can iterate over those entities and collect their recorded events.</p>
<blockquote>
<h4 id="handling-domain-events-with-doctrine-orm">Handling domain events with Doctrine ORM</h4>
<p>This library comes with a <a href="https://maks-rafalko.github.io/tactician-doctrine-domain-events">Doctrine ORM bridge</a>. Using this package you can collect recorded events from Doctrine ORM entities <em>automatically</em> using built in Doctrine Event Subscriber</p>
</blockquote>
                </section>

            </div>
        </main>

        <footer>
            <div class="container-fluid">
                <p class="text-muted">
                    website generated with <a href="http://couscous.io" title="Markdown website generator">Couscous</a>
                </p>
            </div>
        </footer>

        <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
        <script src="//yastatic.net/highlightjs/8.2/highlight.min.js"></script>

        <script>
            $(function() {
                $("section>h1").wrap('<div class="page-header" />');
                // Syntax highlighting
                hljs.initHighlightingOnLoad();
            });
        </script>

    </body>
</html>
